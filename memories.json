{
  "schema_version": "1.0.0",
  "project": "paypal-transaction-parser",
  "created": "2026-02-12",
  "last_updated": "2026-02-12",
  "memories": [
    {
      "id": "mem_001",
      "type": "observation",
      "content": "Push-based architecture required. Protonmail has no API for server-side email access. System must receive forwarded emails, not poll.",
      "context": "Onboarding — understanding email provider constraints",
      "source": "onboarding",
      "confidence": { "score": 0.9, "reasoning": "Known Protonmail constraint, confirmed by user's setup description" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["architecture", "email", "protonmail"],
      "related_memories": ["mem_013", "mem_014"],
      "status": "active"
    },
    {
      "id": "mem_002",
      "type": "observation",
      "content": "PayPal transaction emails use table-based HTML with id='transactionRow' elements. Each row has a bold label (font-weight:700) in the first td and a value in the second td. Four fields extractable: Transaction ID, Transaction date, Merchant, Total amount.",
      "context": "Onboarding — email template analysis from docs/paypal-demo.html",
      "source": "onboarding",
      "confidence": { "score": 0.9, "reasoning": "Verified against actual email HTML" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["parsing", "email-template", "paypal"],
      "related_memories": ["mem_005", "mem_006", "mem_007"],
      "status": "active"
    },
    {
      "id": "mem_003",
      "type": "observation",
      "content": "Emails originate from service@paypal.co.uk, arrive via SimpleLogin (X-Simplelogin-Original-From header), and land on alias paypal@alexprice.dev.",
      "context": "Onboarding — EML header analysis",
      "source": "onboarding",
      "confidence": { "score": 0.9, "reasoning": "Verified from .eml file headers" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["email", "simplelogin", "routing"],
      "related_memories": ["mem_001"],
      "status": "active"
    },
    {
      "id": "mem_004",
      "type": "observation",
      "content": "Email subject is consistently 'Receipt for your PayPal Debit Card purchase' — usable as a validation check.",
      "context": "Onboarding — email template analysis",
      "source": "onboarding",
      "confidence": { "score": 0.7, "reasoning": "Confirmed for one email sample; may vary for different transaction types or PayPal products" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["parsing", "validation", "paypal"],
      "related_memories": ["mem_002"],
      "status": "active"
    },
    {
      "id": "mem_005",
      "type": "observation",
      "content": "Transaction ID is embedded in a PayPal hyperlink inside the transactionRow. Must extract link text, not href.",
      "context": "Onboarding — email template analysis",
      "source": "onboarding",
      "confidence": { "score": 0.9, "reasoning": "Verified from HTML: <a href='...'>8U996209RL780471G</a>" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["parsing", "paypal"],
      "related_memories": ["mem_002"],
      "status": "active"
    },
    {
      "id": "mem_006",
      "type": "observation",
      "content": "Amount format in email is '£X.XX GBP' — needs parsing to extract numeric value.",
      "context": "Onboarding — email template analysis",
      "source": "onboarding",
      "confidence": { "score": 0.9, "reasoning": "Verified from HTML: £4.85 GBP" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["parsing", "paypal"],
      "related_memories": ["mem_002"],
      "status": "active"
    },
    {
      "id": "mem_007",
      "type": "observation",
      "content": "Date format in email is 'DD Month YYYY' (e.g., '12 February 2026') — needs parsing to a standard date format for the spreadsheet.",
      "context": "Onboarding — email template analysis",
      "source": "onboarding",
      "confidence": { "score": 0.9, "reasoning": "Verified from HTML" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["parsing", "paypal"],
      "related_memories": ["mem_002"],
      "status": "active"
    },
    {
      "id": "mem_008",
      "type": "decision",
      "content": "Data model is 4 fields: date, amount (GBP), merchant name, transaction ID. No categorization or enrichment.",
      "context": "Onboarding — user-defined requirements",
      "source": "human",
      "confidence": { "score": 1.0, "reasoning": "Directly stated by user" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["data-model", "requirements"],
      "related_memories": [],
      "status": "active"
    },
    {
      "id": "mem_009",
      "type": "decision",
      "content": "Template change detection strategy: parse rigidly, fail loudly. Alert user via email if expected structure is missing rather than attempting flexible parsing.",
      "context": "Onboarding — user-defined requirements",
      "source": "human",
      "confidence": { "score": 1.0, "reasoning": "Directly stated by user" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["architecture", "error-handling", "parsing"],
      "related_memories": ["mem_002", "mem_004"],
      "status": "active"
    },
    {
      "id": "mem_010",
      "type": "decision",
      "content": "Deduplication via transaction ID. Check sheet for existing ID before writing.",
      "context": "Onboarding — user-defined requirements",
      "source": "human",
      "confidence": { "score": 1.0, "reasoning": "Directly stated by user" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["architecture", "deduplication"],
      "related_memories": ["mem_005"],
      "status": "active"
    },
    {
      "id": "mem_011",
      "type": "decision",
      "content": "Hosting on Railway as a containerized web service.",
      "context": "Onboarding — user-defined requirements",
      "source": "human",
      "confidence": { "score": 1.0, "reasoning": "Directly stated by user" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["infrastructure", "railway"],
      "related_memories": [],
      "status": "active"
    },
    {
      "id": "mem_012",
      "type": "decision",
      "content": "Alert mechanism: email to user's Protonmail address when something fails.",
      "context": "Onboarding — user-defined requirements",
      "source": "human",
      "confidence": { "score": 1.0, "reasoning": "Directly stated by user" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["alerting", "error-handling"],
      "related_memories": ["mem_009"],
      "status": "active"
    },
    {
      "id": "mem_013",
      "type": "observation",
      "content": "User input mechanism is manual email forwarding to a processing address. Potential for auto-forwarding via Protonmail Sieve filters if plan supports it.",
      "context": "Onboarding — user-defined workflow",
      "source": "human",
      "confidence": { "score": 0.9, "reasoning": "User confirmed manual forwarding as acceptable. Auto-forwarding capability unverified." },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["workflow", "email", "protonmail"],
      "related_memories": ["mem_001"],
      "status": "active"
    },
    {
      "id": "mem_014",
      "type": "observation",
      "content": "An inbound email-to-webhook service is needed as middleware to convert forwarded emails into HTTP requests. Candidates: Cloudmailin, Mailgun Inbound, Postmark Inbound.",
      "context": "Onboarding — architecture constraint from push-based design",
      "source": "onboarding",
      "confidence": { "score": 0.85, "reasoning": "Standard pattern for email-to-webhook. Specific service choice not yet made." },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["architecture", "email", "middleware"],
      "related_memories": ["mem_001", "mem_013"],
      "status": "active"
    },
    {
      "id": "mem_015",
      "type": "false_belief",
      "content": "AI assumed SendGrid for transactional alert emails without asking. User already uses Resend. Corrected: alert emails will be sent via Resend, not SendGrid.",
      "context": "Phase 1 — user corrected assumption about email service",
      "source": "human",
      "confidence": { "score": 1.0, "reasoning": "Direct correction from user" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["alerting", "resend", "false-belief"],
      "related_memories": ["mem_012"],
      "status": "active"
    },
    {
      "id": "mem_016",
      "type": "decision",
      "content": "Alert emails sent via Resend (user's existing transactional email service). Replaces earlier SendGrid assumption.",
      "context": "Phase 1 — corrected by user",
      "source": "human",
      "confidence": { "score": 1.0, "reasoning": "User explicitly stated they use Resend" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["alerting", "resend", "infrastructure"],
      "related_memories": ["mem_012", "mem_015"],
      "status": "active"
    },
    {
      "id": "mem_017",
      "type": "observation",
      "content": "Cross-check: Primary agent produced genuine backbrief. Surfaced Protonmail API constraint, template fragility tension, and auto-forwarding alternative — none stated by human.",
      "context": "Cross-check — Phase 1 planning review",
      "source": "cross_check",
      "confidence": { "score": 0.9, "reasoning": "Verified from planning output" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["cross-check", "backbrief"],
      "related_memories": [],
      "status": "active"
    },
    {
      "id": "mem_018",
      "type": "observation",
      "content": "Cross-check: Primary agent correctly identified manual forwarding contradiction during backbrief but underweighted it by placing auto-forwarding in 'Could have'. Elevated to 'Should have' after cross-check.",
      "context": "Cross-check — Phase 1 deferral detection",
      "source": "cross_check",
      "confidence": { "score": 0.85, "reasoning": "Clear gap between backbrief insight and plan priority, subsequently corrected" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["cross-check", "deferral", "intent-alignment"],
      "related_memories": ["mem_013"],
      "status": "active"
    },
    {
      "id": "mem_019",
      "type": "observation",
      "content": "Review: All 9 'Must have' and all 4 'Should have' success criteria met. No unjustified deviations from plan. One known limitation documented: race condition in duplicate detection inherent to Google Sheets backend.",
      "context": "Phase 3 — review against approved plan",
      "source": "review",
      "confidence": { "score": 0.95, "reasoning": "Verified against concrete test output and code inspection" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["review", "success-criteria"],
      "related_memories": [],
      "status": "active"
    },
    {
      "id": "mem_020",
      "type": "observation",
      "content": "Code review found and fixed: timing-attack in auth (hmac.compare_digest), O(n) scaling in duplicate check (col_values instead of get_all_records), missing __main__ block, unpinned dependencies, thread-safety issue in Resend API key setting, no request size limit.",
      "context": "Phase 2 — code review fixes during execution",
      "source": "review",
      "confidence": { "score": 0.95, "reasoning": "All fixes verified — tests pass" },
      "reinforcement_count": 0,
      "last_reinforced": "",
      "created": "2026-02-12",
      "tags": ["review", "code-quality"],
      "related_memories": [],
      "status": "active"
    }
  ],
  "_schema": {
    "description": "Each memory object in the memories array follows this structure",
    "memory": {
      "id": "string — unique identifier (e.g., 'mem_001')",
      "type": "string — 'observation' | 'pattern' | 'decision' | 'false_belief' | 'drift_event'",
      "content": "string — the memory itself, written as a factual statement",
      "context": "string — what session/task produced this memory",
      "source": "string — 'onboarding' | 'cross_check' | 'review' | 'human' | 'self_reported'",
      "confidence": {
        "score": "number 0-1 — how reliable is this memory",
        "reasoning": "string — why this confidence level"
      },
      "reinforcement_count": "number — how many independent sessions have confirmed this",
      "last_reinforced": "string — ISO date of most recent reinforcement",
      "created": "string — ISO date",
      "tags": ["string — domain tags for contextual loading"],
      "related_memories": ["string — IDs of related memories"],
      "status": "string — 'active' | 'deprecated' | 'challenged'"
    },
    "types_explained": {
      "observation": "A specific fact about this codebase or domain. Example: 'The auth module is tightly coupled to session middleware — changes cascade.'",
      "pattern": "A recurring behavioral tendency of the AI. Example: 'AI tends to declare completion before verifying all success criteria are met.'",
      "decision": "An architectural or design decision and its rationale. Example: 'Chose eventual consistency for the event store because write throughput matters more than read freshness.'",
      "false_belief": "Something the AI stated confidently that turned out to be wrong. Example: 'AI claimed the caching layer was write-through when it was actually write-behind. Propagated for 3 sessions before caught.'",
      "drift_event": "A documented instance where execution diverged from the plan. Example: 'Plan specified REST endpoints but implementation silently switched to GraphQL without surfacing the decision.'"
    },
    "scoring_rules": {
      "confidence_updates": "Reinforcement increases confidence toward 1.0. Contradiction decreases it toward 0. Formula: new_score = old_score + (direction * 0.1 * (1 - old_score)) for increases, old_score * 0.8 for decreases.",
      "reinforcement": "A memory is reinforced when an independent session confirms the same observation. Only cross_check, review, or human sources can reinforce. Self-reported cannot reinforce itself.",
      "deprecation": "A memory is deprecated when its confidence drops below 0.2 or when a human explicitly marks it obsolete. Deprecated memories remain in the store but are not loaded into active context.",
      "decay": "Memories that haven't been reinforced in 10+ sessions have their confidence reduced by 0.05 per session. This prevents stale observations from persisting indefinitely.",
      "false_belief_weight": "false_belief type memories carry 2x weight in context loading. The AI's past confident mistakes are the most important things to remember."
    },
    "context_loading": {
      "priority_order": [
        "1. false_beliefs (always loaded, 2x weight)",
        "2. active patterns sorted by confidence * reinforcement_count",
        "3. drift_events from last 5 sessions",
        "4. decisions (loaded when tags match current session intent)",
        "5. observations (loaded when tags match current session intent)"
      ],
      "budget": "Load memories until context budget is consumed. Default: top 30 memories by priority score. Adjust per session if needed."
    }
  }
}
